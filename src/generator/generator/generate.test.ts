import { strictEqual } from 'node:assert';
import { readFile } from 'node:fs/promises';
import { join } from 'node:path';
import { dedent } from 'ts-dedent';
import type { DatabaseMetadataOptions } from '../../introspector';
import { DatabaseMetadata } from '../../introspector';
import {
  addExtraColumn,
  migrate,
} from '../../introspector/introspector.fixtures';
import { ArrayExpressionNode } from '../ast/array-expression-node';
import { GenericExpressionNode } from '../ast/generic-expression-node';
import { IdentifierNode, TableIdentifierNode } from '../ast/identifier-node';
import { RawExpressionNode } from '../ast/raw-expression-node';
import type { GeneratorDialect } from '../dialect';
import { SqliteDialect } from '../dialects/sqlite/sqlite-dialect';
import { Logger } from '../logger/logger';
import { toKyselyCamelCase } from '../utils/case-converter';
import type { GenerateOptions, SerializeFromMetadataOptions } from './generate';
import { generate, serializeFromMetadata } from './generate';

const SNAPSHOTS_DIR = join(__dirname, 'snapshots');

describe(generate.name, () => {
  const baseGenerateOptions: Omit<GenerateOptions, 'db' | 'dialect'> = {
    camelCase: true,
    overrides: {
      columns: {
        'foo_bar.overridden': new RawExpressionNode('"OVERRIDDEN"'),
      },
    },
  };

  it('should generate the correct output for SQLite', async () => {
    const dialect = new SqliteDialect();
    const connectionString = ':memory:';
    const db = await migrate(dialect, connectionString);
    const output = await generate({
      ...baseGenerateOptions,
      db,
      dialect,
    });
    const expectedOutput = await readFile(
      join(SNAPSHOTS_DIR, 'sqlite.snapshot.ts'),
      'utf8',
    );
    strictEqual(output, expectedOutput);
    await db.destroy();
  });

  it('should verify generated types for SQLite', async () => {
    const dialect = new SqliteDialect();
    const connectionString = ':memory:';
    const db = await migrate(dialect, connectionString);
    const outFile = join(SNAPSHOTS_DIR, 'sqlite.snapshot.ts');
    await generate({
      ...baseGenerateOptions,
      db,
      dialect,
    });
    await addExtraColumn(db);

    try {
      await generate({
        ...baseGenerateOptions,
        db,
        dialect,
        outFile,
        verify: true,
      });
    } catch (error: unknown) {
      if (error instanceof Error) {
        strictEqual(
          error.message,
          "Generated types are not up-to-date! Use '--log-level=error' option to view the diff.",
        );
      } else {
        throw error;
      }
    }

    await db.destroy();
  });
});

describe(serializeFromMetadata.name, () => {
  const serialize = (
    options: Omit<SerializeFromMetadataOptions, 'dialect' | 'metadata'> & {
      dialect?: GeneratorDialect;
      metadata: DatabaseMetadataOptions;
    },
  ) => {
    return serializeFromMetadata({
      ...options,
      dialect: options.dialect ?? new SqliteDialect(),
      metadata: new DatabaseMetadata(options.metadata),
      skipAutogeneratedFileComment: true,
    }).trimEnd();
  };

  test('camelCase', () => {
    expect(
      serialize({
        camelCase: true,
        metadata: {
          tables: [
            {
              columns: [{ dataType: 'INTEGER', name: 'baz_qux' }],
              name: 'foo_bar',
            },
          ],
        },
      }),
    ).toStrictEqual(
      dedent`
        export interface FooBar {
          bazQux: number;
        }

        export interface DB {
          fooBar: FooBar;
        }
      `,
    );
  });

  test('logger', () => {
    class ArrayLogger extends Logger {
      readonly messages: string[] = [];

      debug(message = '') {
        this.messages.push(message);
      }
    }

    const logger = new ArrayLogger();

    serialize({
      logger,
      metadata: { tables: [{ columns: [], name: 'table' }] },
    });

    expect(logger.messages).toStrictEqual([
      '',
      'Found 1 public table:',
      ' - table',
      '',
    ]);
  });

  test('overrides', () => {
    expect(
      serialize({
        metadata: {
          tables: [
            {
              columns: [{ dataType: 'TEXT', name: 'author' }],
              name: 'posts',
            },
            {
              columns: [
                { dataType: 'TEXT', name: 'posts' },
                { dataType: 'TEXT', name: 'settings' },
              ],
              name: 'users',
            },
          ],
        },
        overrides: {
          columns: {
            'posts.author': new TableIdentifierNode('User'),
            'users.settings': '{ theme: "dark" }',
            'users.posts': new ArrayExpressionNode(
              new TableIdentifierNode('Post'),
            ),
          },
        },
      }),
    ).toStrictEqual(
      dedent`
        export interface Posts {
          author: User;
        }

        export interface Users {
          posts: Post[];
          settings: { theme: "dark" };
        }

        export interface DB {
          posts: Posts;
          users: Users;
        }
      `,
    );
  });

  test('serializer', () => {
    expect(
      serialize({
        metadata: {
          tables: [
            {
              columns: [{ dataType: 'INTEGER', name: 'baz_qux' }],
              name: 'users',
              schema: 'public',
            },
          ],
        },
        serializer: {
          serializeFile: (metadata) => {
            let output = 'import { z } from "zod";\n\n';

            for (const table of metadata.tables) {
              output += 'export const ';
              output += toKyselyCamelCase(table.name);
              output += 'Schema = z.object({\n';

              for (const column of table.columns) {
                output += '  ';
                output += column.name;
                output += ': ';

                switch (column.dataType) {
                  case 'INTEGER':
                    output += 'z.number().int()';
                    break;
                  default:
                    output += 'z.unknown()';
                }

                output += ',\n';
              }

              output += '});\n\n';
            }

            return output;
          },
        },
      }),
    ).toStrictEqual(
      dedent`
        import { z } from "zod";

        export const usersSchema = z.object({
          baz_qux: z.number().int(),
        });
      `,
    );
  });

  test('singularize', () => {
    expect(
      serialize({
        metadata: {
          tables: [{ columns: [], name: 'users', schema: 'public' }],
        },
        singularize: { '/^(.*?)s?$/': '$1_model' },
      }),
    ).toStrictEqual(
      dedent`
        export interface UserModel {}

        export interface DB {
          users: UserModel;
        }
      `,
    );
  });

  test('customImports', () => {
    expect(
      serialize({
        customImports: {
          InstantRange: './custom-types',
          MyCustomType: '@my-org/custom-types',
        },
        metadata: {
          tables: [
            {
              columns: [
                { dataType: 'TEXT', name: 'date_range' },
                { dataType: 'TEXT', name: 'metadata' },
              ],
              name: 'events',
              schema: 'public',
            },
          ],
        },
        overrides: {
          columns: {
            'events.date_range': new GenericExpressionNode('ColumnType', [
              new IdentifierNode('InstantRange'),
              new IdentifierNode('InstantRange'),
              new IdentifierNode('never'),
            ]),
            'events.metadata': new IdentifierNode('MyCustomType'),
          },
        },
      }),
    ).toStrictEqual(
      dedent`
        import type { InstantRange } from "./custom-types";
        import type { MyCustomType } from "@my-org/custom-types";
        import type { ColumnType } from "kysely";

        export interface Events {
          date_range: ColumnType<InstantRange, InstantRange, never>;
          metadata: MyCustomType;
        }

        export interface DB {
          events: Events;
        }
      `,
    );
  });

  test('customImports with # syntax for named exports', () => {
    expect(
      serialize({
        customImports: {
          InstantRange: './custom-types#CustomInstantRange',
          MyType: '@org/types#OriginalType',
          SameNameImport: './utils#SameNameImport',
        },
        metadata: {
          tables: [
            {
              columns: [
                { dataType: 'TEXT', name: 'date_range' },
                { dataType: 'TEXT', name: 'user_type' },
                { dataType: 'TEXT', name: 'data' },
              ],
              name: 'events',
              schema: 'public',
            },
          ],
        },
        overrides: {
          columns: {
            'events.date_range': new GenericExpressionNode('ColumnType', [
              new IdentifierNode('InstantRange'),
              new IdentifierNode('InstantRange'),
              new IdentifierNode('never'),
            ]),
            'events.user_type': new IdentifierNode('MyType'),
            'events.data': new IdentifierNode('SameNameImport'),
          },
        },
      }),
    ).toStrictEqual(
      dedent`
        import type { CustomInstantRange as InstantRange } from "./custom-types";
        import type { SameNameImport } from "./utils";
        import type { OriginalType as MyType } from "@org/types";
        import type { ColumnType } from "kysely";

        export interface Events {
          data: SameNameImport;
          date_range: ColumnType<InstantRange, InstantRange, never>;
          user_type: MyType;
        }

        export interface DB {
          events: Events;
        }
      `,
    );
  });

  test('typeMapping', () => {
    expect(
      serialize({
        customImports: {
          Temporal: '@js-temporal/polyfill',
        },
        metadata: {
          tables: [
            {
              columns: [
                { dataType: 'INTEGER', name: 'id' },
                { dataType: 'TEXT', name: 'created_at' },
              ],
              name: 'time_data',
            },
          ],
        },
        typeMapping: {
          text: 'Temporal.Instant',
        },
      }),
    ).toStrictEqual(
      dedent`
        import type { Temporal } from "@js-temporal/polyfill";

        export interface TimeData {
          created_at: Temporal.Instant;
          id: number;
        }

        export interface DB {
          time_data: TimeData;
        }
      `,
    );
  });
});
