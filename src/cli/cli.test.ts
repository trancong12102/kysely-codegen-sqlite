import type { Config } from 'cosmiconfig';
import { execa } from 'execa';
import { deepStrictEqual } from 'node:assert';
import { join } from 'node:path';
import { dedent } from 'ts-dedent';
import packageJson from '../../package.json';
import { Cli } from './cli';
import { ConfigError } from './config-error';

const BINARY_PATH = join(
  process.cwd(),
  packageJson.bin['kysely-codegen-sqlite'],
);

describe(Cli.name, () => {
  beforeAll(async () => {
    await execa`pnpm build`;
  });

  it('should be able to start the CLI', async () => {
    const output = await execa`node ${BINARY_PATH} --help`.then(
      (r) => r.stdout,
    );
    deepStrictEqual(output.includes('--help, -h'), true);
  });

  it('should be able to run the CLI programmatically with a custom config object', async () => {
    const output = await new Cli().run({
      argv: ['--camel-case'],
      config: {
        logLevel: 'silent',
        outFile: null,
        url: ':memory:',
      },
    });

    expect(output).toStrictEqual(
      dedent`
        /**
         * This file was generated by kysely-codegen-sqlite.
         * Please do not edit it manually.
         */

        export interface DB {}

      `,
    );
  });

  it('should parse options correctly', () => {
    const assert = (args: string[], expectedOptions: Partial<Config>) => {
      const cliOptions = new Cli().parseOptions(args, { silent: true });
      deepStrictEqual(cliOptions, { camelCase: true, ...expectedOptions });
    };

    assert(['--camel-case'], { camelCase: true });
    assert(['--custom-imports={"InstantRange":"./custom-types"}'], {
      customImports: { InstantRange: './custom-types' },
    });
    assert(['--custom-imports={"MyType":"@org/types#OriginalType"}'], {
      customImports: { MyType: '@org/types#OriginalType' },
    });
    assert(['--default-schema=foo'], { defaultSchemas: ['foo'] });
    assert(['--default-schema=foo', '--default-schema=bar'], {
      defaultSchemas: ['foo', 'bar'],
    });
    assert(['--exclude-pattern=public._*'], { excludePattern: 'public._*' });
    assert(['--help'], {});
    assert(['-h'], {});
    assert(['--include-pattern=public._*'], { includePattern: 'public._*' });
    assert(['--log-level=debug'], { logLevel: 'debug' });
    assert(['--no-type-only-imports'], { typeOnlyImports: false });
    assert(['--out-file=./db.ts'], { outFile: './db.ts' });
    assert(
      ['--overrides={"columns":{"table.override":"{ foo: \\"bar\\" }"}}'],
      { overrides: { columns: { 'table.override': '{ foo: "bar" }' } } },
    );
    assert(['--print'], { print: true });
    assert(['--singularize'], { singularize: true });
    assert(
      [
        '--type-mapping={"timestamptz":"Temporal.Instant","tstzrange":"InstantRange"}',
      ],
      {
        typeMapping: {
          timestamptz: 'Temporal.Instant',
          tstzrange: 'InstantRange',
        },
      },
    );
    assert(['--type-only-imports'], { typeOnlyImports: true });
    assert(['--type-only-imports=false'], { typeOnlyImports: false });
    assert(['--type-only-imports=true'], { typeOnlyImports: true });
    assert(['--url=:memory:'], { url: ':memory:' });
    assert(['--verify'], { verify: true });
    assert(['--verify=false'], { verify: false });
    assert(['--verify=true'], { verify: true });
  });

  it('should throw an error if a flag is deprecated', () => {
    expect(() => new Cli().parseOptions(['--schema'])).toThrow(
      new RangeError(
        "The flag 'schema' has been deprecated. Use 'default-schema' instead.",
      ),
    );
    expect(() => new Cli().parseOptions(['--singular'])).toThrow(
      new RangeError(
        "The flag 'singular' has been deprecated. Use 'singularize' instead.",
      ),
    );
  });

  it('should throw an error if the config has an invalid schema', () => {
    const assert = (
      config: any,
      message: string,
      path = [Object.keys(config)[0]!],
    ) => {
      expect(() => new Cli().parseOptions([], { config })).toThrow(
        new ConfigError({ message, path }),
      );
    };

    assert(
      { camelCase: 'true' },
      'Invalid input: expected boolean, received string',
    );
    assert(
      { customImports: [] },
      'Invalid input: expected record, received array',
    );
    assert(
      { camelCase: 'true' },
      'Invalid input: expected boolean, received string',
    );
    assert(
      { defaultSchemas: 'public' },
      'Invalid input: expected array, received string',
    );
    assert({ envFile: null }, 'Invalid input: expected string, received null');
    assert(
      { excludePattern: false },
      'Invalid input: expected string, received boolean',
    );
    assert(
      { includePattern: false },
      'Invalid input: expected string, received boolean',
    );
    assert(
      { logLevel: 0 },
      'Invalid option: expected one of "silent"|"error"|"warn"|"info"|"debug"',
    );
    assert(
      { outFile: false },
      'Invalid input: expected string, received boolean',
    );
    assert(
      { overrides: { columns: [] } },
      'Invalid input: expected record, received array',
      ['overrides', 'columns'],
    );
    assert(
      { print: 'true' },
      'Invalid input: expected boolean, received string',
    );
    assert({ singularize: 'true' }, 'Invalid input');
    assert(
      { typeOnlyImports: 'true' },
      'Invalid input: expected boolean, received string',
    );
    assert({ url: null }, 'Invalid input: expected string, received null');
    assert(
      { verify: 'true' },
      'Invalid input: expected boolean, received string',
    );
  });
});
